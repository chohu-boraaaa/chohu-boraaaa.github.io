---
layout: post  
title: "[자료구조] 1장. 자료구조와 알고리즘"
date: 2022-10-06
excerpt: "파이썬으로 쉽게 풀어쓴 자료구조 1장을 정리한 내용입니다"
tag:
- 자료구조
comments: true
--- 

# 1.1 자료구조와 알고리즘

---

|용어|설명|
|---|-----|
|자료구조|컴퓨터가 자료를 정리하고 조직화하는 구조들|
|선형자료구조|항목들을 순서적으로 나열, 저장하는 창고</br>- 종류 : 스택, 큐, 덱, 리스트|
|비선형자료구조|저장되는 항목들이 복잡한 연결 관계를 가지는 구조</br>- 종류 : 힙, 이진 탐색트리, AVL트리, 그래프, 가중치 그래프|
|알고리즘|컴퓨터로 문제를 풀기 위한 단계적인 절차|
|프로그램|자료구조 + 알고리즘|
|알고리즘의 5가지 조건|입력, 출력, 명백성, 유한성, 유효성|
|조건1-입력|0개 이상의 입력이 존재해야 함|
|조건2-출력|1개 이상의 출력이 존재해야 함|
|조건3-명백성|각 명령어의 의미는 모호하지 않고 명백해야 함|
|조건4-유한성|한정된 수의 단계 후에는 반드시 종료되어야 함|
|조건5-유효성|각 명령어들은 실행 가능한 연산이어야 함|
|알고리즘 기술방법(4)|자연어, 흐름도, 유사코드, 특정언어|
|자연어|읽기 쉬움. 단어들을 정확하게 정의하지 않으면 의미 모호|
|흐름도|직관적. 이해하기 쉬움. 복잡한 알고리즘이면 상당히 복잡|
|유사코드|-프로그램 구현 시 여러 문제들을 감출 수 있음</br>-알고리즘의 핵심적인 내용에만 집중 가능|
|특정언어|-알고리즘의 가장 정확한 기술</br>-구현 시의 사항들이 알고리즘의 핵심적인 내용들의 이해를 방해</br>-C나 자바보다 훨씬 간결하게 표현 가능|

# 1.2 추상 자료형

---

|용어|설명|
|---|-----|
|추상자료형</br>(Abstract Data Type,</br>ADT)|데이터 타입을 추상적(수학적)으로 정의한 것</br>-어떤(what?) 자료나 연산이 제공되는가만 정의</br>-어떻게(how?) 구현되는가는 **정의하지 않는다**</br>- 간단한 인터페이스만 제공</br>-시스템의 정말 핵심적인 구조나 동작에만 집중</br>-**클래스**로 구현하는 것이 바람직</br>-추상자료형의 **데이터나 연산**이 클래스의 **상태와 행위**에 정확히 대응|
|정보은닉|추상자료형의 특징 : 추후에 구현 방법이 변경되더라도 인터페이스만 정확히 지켜지면 사용자는 변경된 내용을 힘들게 공부할 필요 없이 동일하게 사용 가능|

# 1.3 알고리즘의 성능 분석

---

|용어|설명|
|---|-----|
|알고리즘의 성능 분석 기법|-실행시간 측정법</br>-알고리즘 복잡도 분석법|
|실행시간 측정법|-두 개의 알고리즘의 실제 실행 시간을 측정</br>-실제로 구현하는 것이 필요</br>-동일한 하드웨어 사용해야 함</br>-소프트웨어 환경이 동일해야 함</br>-다른 데이터에는 다른 결과가 나올 수 있음|
|알고리즘 복잡도 분석법|-직접 구현하지 않고 수행시간 분석</br>-알고리즘이 수행하는 연산의 횟수를 측정하여 비교</br>-일반적으로 연산의 횟수는 n의 함수</br>-**시간 복잡도 분석** : 수행 시간 분석</br>-**공간 복잡도 분석** : 수행 시 필요로 하는 메모리 공간 분석|
|시간 복잡도|-산술,대입,비교,이동의 기본적인 연산 고려</br>-알고리즘 수행에 필요한 연산의 개수를 계산</br>-입력의 개수 n에 대한 함수 = **시간복잡도 함수, T(n)**|
|빅오표기법|차수가 가장 큰 항의 영향이 절대적이라는 성질을 이용하여 최고차항을 고려하여 표기</br>-n에 따른 함수의 상한|
|실행시간 최선의 경우</br>(best case)|수행 시간이 가장 빠르지만 의미가 없는 경우 많음|
|실행시간 평균의 경우</br>(average case)|수행시간이 평균적인 경우 - 계산하기가 어려움|
|실행시간 최악의 경우</br>(worst case)|수행시간이 가장 늦은 경우-가장 중요|


## ✅ 시간 복잡도 구하기

![](https://user-images.githubusercontent.com/77424107/196223478-e38ceb17-6217-462a-b30f-7835b0ae49ca.png)

## ✅ 빅오 표기법

![](https://user-images.githubusercontent.com/77424107/196451585-0e0ea7be-2cdc-4e16-bcf4-c6a66af4fd77.png)

![](https://slidesplayer.org/slide/17654672/105/images/26/%EB%B9%85%EC%98%A4+%ED%91%9C%EA%B8%B0%EB%B2%95%EC%9D%98+%EC%A2%85%EB%A5%98+O%281%29+%3A+%EC%83%81%EC%88%98%ED%98%95+O%28logn%29+%3A+%EB%A1%9C%EA%B7%B8%ED%98%95+O%28n%29+%3A+%EC%84%A0%ED%98%95+O%28nlogn%29+%3A+%EB%A1%9C%EA%B7%B8%EC%84%A0%ED%98%95.jpg)


## ✅ 빅오메가 표기법

![](https://user-images.githubusercontent.com/77424107/196454489-b3dc0993-1b99-4164-81d8-4757c2131c14.png)

## ✅ 빅세타 표기법

![](https://user-images.githubusercontent.com/77424107/196454811-07c01636-5813-4a74-b0b1-b4658af8dbdd.png)

# 1.4 시간 복잡도 분석 : 순환 알고리즘

---

|용어|설명|
|---|-----|
|순환 알고리즘|알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법|
|팩토리얼|-순환 : O(n), 순환적인 문제에서는 자연스러운 방법. 함수 호출의 오버헤드.</br>-반복 : O(n), 실행속도가 빠름. 순환적인 문제에서는 프로그램 작성이 어려울 수 있음.|
|거듭제곱 계산|-반복구조 : O(n)</br>-순환구조 : 문제의 크기가 절반씩 줄어들기 때문에 O($log_2n$)|
|피보나치 수열 계산|-반복 구조 : O(n)</br>-순환 구조 : O($2^n$)|

## ✅ 하노이탑 시간복잡도함수

![](https://user-images.githubusercontent.com/77424107/196495752-f23845f3-860b-41f0-9e19-e58b4507c349.png)