---   
layout: post  
title: "[정보처리기사] 실기 1장. 요구사항 확인"
date: 2022-10-09
excerpt: "정보처리기사 실기 1장 정리한 내용입니다."
tag:
- 정처기
comments: true
--- 

# SECTION 1. 소프트웨어 생명 주기

---

## 1. 소프트웨어 생명 주기(Software Life Cycle)
- 소프트웨어를 개발하기 위한 과정을 각 단계별로 나눈 것
- **소프트웨어 개발 단계**, **각 단계별 주요 활동**, **활동의 결과에 대한 산출물**로 표현

## 2. 폭포수 모형
- 각 단계를 확실히 매듭짓고 결과를 검토하여 승인 과정을 거친 후 다음 단계를 진행하는 개발 방법론
- 고전적 생명 주기 모형
- 모형을 적용한 경험과 성공 사례가 많음
- 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출

## 3. 프로토타입 모형(Prototype Model, 원형 모형)
- 사용자의 요구사항을 파악하기 위해 **실제 개발될 소프트웨어**에 대한 **견본품(Prototype)을 만들어 최종 결과물을 예측하는 모형**
- 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발

## 4. 나선형 모형(Spiral Model, 점진적 모형)
- **여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로** 완벽한 최종 소프트웨어를 개발하는 모형
- 보헴이 제안
- 폭포수 모형과 프로토타입 모형의 장점에 **위험 분석 기능**을 추가한 모형
- 누락되거나 추가된 요구사항 첨가 가능
- 유지보수 과정이 필요 없음
- ![](https://mblogthumb-phinf.pstatic.net/MjAyMDAzMjBfMTI3/MDAxNTg0NjkyNTMwMTc0.02Ol8F0dMj_7cxeIztTCnUzfYONYnVPalmr2AxFNjP4g.nCFoxVW19mbeR7wzavJO7bxkCLNDU2JP8WHUTddPvB8g.PNG.handuelly/image.png?type=w800)
- 출처 : https://m.blog.naver.com/handuelly/221863874937

## 5. 애자일 모형
- 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형
- 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭
- 폭포수 모형과 대조적
- 기업 활동 전반에 걸쳐 사용
- 대표적인 개발 모형 : 스크럼, XP(eXtreme Programming), 칸반(Kanban), Lean, 기능 중심 개발(FDD;Feature Driven Development)

## 6. 애자일 개발 4가지 핵심 가치
- 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둠
- 방대한 문서보다는 실행되는 SW에 더 가치를 둠
- 계약 협상보다는 고객과 협업에 더 가치를 둠
- 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둠

## 7. 소프트웨어 공학
- 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문
- 목적 : 여러 가지 방법론과 도구, 관리 기법들을 통해 소프트웨어의 품질과 생산성 향상

### ✔️ 소프트웨어 공학의 기본 원칙
- 현대적인 프로그래밍 기술을 계속적으로 적용
- 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증
- 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록 유지

# SECTION 2. 스크럼 기법

---

## 1. 스크럼
- 팀이 중심이 되어 개발의 효율성을 높이는 기법
- 팀원 스스로가 스크럼 팀을 구성하고 개발 작업에 관한 모든 것을 스스로 해결할 수 잇어야 함

## 2. 스크럼 팀
- 제품 책임자(PO, Product Owner) : 요구사항이 담긴 백로그를 작성하는 주체, 이해관계자들 중 개발될 제품에 대한 **이해도가 높고 요구사항을 책임지고 의사를 결정할 사람**으로 선정
- 스크럼 마스터(SM, Scrum Master) : 스크럼 팀이 스크럼을 잘 수행할 수 있도록 **가이드 역할**을 수행
- 개발팀(DT, Developmnet Team) : 제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로 제품 개발 수행

## 3. 스크럼 개발 프로세스

### 3-1. 스프린트 계획 회의(Sprint Planning Meeting)
- 제품 백로그 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립하는 회의

### 3-2. 스프린트
- 실제 개발 작업을 진행하는 과정으로, 보통 2~4주 정도의 기간 내에서 진행

### 3-3. 일일 스크럼 회의
- 모든 팀원이 매일 약속된 시간에 약 15분 동안 진행 상황 점검하는 회의
- 남은 작업 시간은 소멸 차트(Burn-down chart)에 표시

### 3-4. 스프린트 검토 회의
- 부분 또는 전체 완성 제품이 요구사항에 잘 부합하는지 테스팅하는 회의

### 3-5. 스프린트 회고
- 정해놓은 규칙 준수 여부 및 개선할 점을 확인하고 기록

# 3. XP(eXtreme Programming)

---

## 1. XP
- 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법
- 목적 : 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것
- 릴리즈(부분적으로 기능이 완료된 제품을 제공)의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높임
- XP의 핵심 5가지 핵심 가치 : 의사소통, 단순성, 용기, 존중, 피드백

## 2. XP 개발 프로세스
- ![](https://velog.velcdn.com/images/chs122/post/de08c21a-9219-4a08-a7af-f1d47f4a07b3/image.png)
- 출처 : https://velog.io/@chs122/XPeXtreme-Programming

### 2-1. 릴리즈 계획 수립
- 부분 혹은 전체 개발 완료 시점에 대한 일정 수립
- **릴리즈** : 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것

### 2-2. 이터레이션(iteration, 주기)
- 실제 개발 작업을 진행하는 과정
- 보통 1~3주 정도의 기간으로 진행

### 2-3. 승인 검사(Acceptance Test, 인수 테스트)
- 하나의 이터레이션 안에서 부분 완료 제품이 구현되면 수행하는 테스트

### 2-4. 소규모 릴리즈
- 요구사항에 유연하게 대응할 수 있도록 릴리즈 규모를 축소한 것

## 3. XP의 주요 실천 방법
- Pair Programming(짝 프로그래밍) : 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경 조성
- Collective Ownership(공동 코드 소유) : 개발 코드에 대한 권한과 책임을 공동으로 소유
- Test-Driven Development(테스트 주도 개발) : 테스트 케이스를 먼저 작성하여 개발자가 무엇을 해야 할지 파악, 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 사용
- Whole Team(전체 팀) : 개발에 참여하는 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 그 역할에 대한 책임 가져야 함
- Continuous Integration(계속적인 통합) : 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리될 떄마다 지속적으로 통합됨
- Refactoring(리팩토링) : 프로그래밍 기능의 변경 없이 시스템 재구성, 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하는 목적
- Small Release(소규모 릴리즈) : 릴리즈 기간을 짧게 반복하면서 고객의 요구 변화에 신속 대응

# SECTION 4. 현행 시스템 파악

---

## 1. 현행 시스템 파악 절차

### 1-1. 1단계

#### 1) 시스템 구성 파악
- 조직의 주요 업무를 담당하는 기간 업무와 이를 지원하는 지원업무로 구분

#### 2) 시스템 기능 파악
- 주요기능, 하부 기능, 세부 기능으로 구분하여 계층형으로 표시

#### 3) 시스템 인터페이스 파악
- 단위 업무 시스템 간 주고받는 데이터 종류, 형식, 프로토콜, 연계 유형, 주기를 명시

### 1-2. 2단계

#### 1) 아키텍처 구성 파악
- 최상위 수준에서 계층별로 표현한 아키텍처 구성도 작성

#### 2) 소프트웨어 구성 파악
- 소프트웨어의 제품명, 용도, 라이선스 적용 방식, 라이선스 수 등을 명시

### 1-3. 3단계

#### 1) 하드웨어 구성 파악
- 단위 업무 시스템들이 운용되는 서버의 주요 사양과 수량, 서버의 이중화 적용 여부 명시

#### 2) 네트워크 구성 파악
- 서버 위치, 서버 간 네트워크 연결 방식을 네트워크 구성도로 작성

# SECTION 5. 개발 기술 환경 파악

## 1. 운영 체제
- 컴퓨터 시스템의 자원을 효율적으로 관리하며, 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어
- 사용자와 하드웨어 간 인터페이스 담당
- 다른 응용 프로그램이 유용한 작업할 수 있도록 환경 제공
- 운영체제 관련 요구사항 식별 시 고려사항 : 가용성, 성능, 기술 지원, **주변 기기**, 구축 비용

## 2. 데이터베이스 관리 시스템(DBMS, DataBase Management System)
- 사용자와 데이터베이스 사이에서 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어
- 기존 파일 시스템이 갖는 데이터 중복성과 종속성의 문제를 해결하기 위함
- 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 함
- DBMS 관련 요구사항 식별 시 고려사항 : 가용성, 성능, 기술지원, **상호 호환성**, 구축 비용

## 3. 웹 애플리케이션 서버(WAS)
- 동적인 콘텐츠를 처리하기 위해 사용되는 **미들 웨어**
- 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리 제공
- 주로 데이터베이스와 연동해서 사용
- 고려사항 : 가용성, 성능, 기술지원, 구축비용

## 4. 오픈소스
- 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어
- 고려사항 : 라이선스의 종류, 사용자 수, 기술의 지속 가능성

# SECTION 6. 요구사항 정의

---

## 1. 요구사항
- 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 운영되는데 필요한 제약조건
- 개발이나 유지 보수 과정에서 필요한 기준이나 근거 제공
- 개발에 참여하는 이해 관계자들 간 의사소통을 원활하게 해줌
- 유형 : 기능 요구사항, 비기능 요구사항, 사용자 요구사항, 시스템 요구사항

## 2. 기능 요구사항(Functional Requirements)
- 기능이나 수행과 관련된 요구사항
- 시스템 입력이나 출력으로 무엇이 포함되어야 하는지에 대한 사항
- 어떤 데이터를 저장하거나 연산을 수행해야 하는지
- 시스템이 반드시 수행해야 하는 사항
- 사용자가 시스템을 통해 제공받기를 원하는 기능

## 3. 비기능 요구사항(Non-Fuctional Requirements)
- 품질이나 제약사항과 관련된 요구사항
- 시스템 장비 구성, 성능, 인터페이스, 데이터를 구축하기 위한, 테스트, 보안, 프로젝트 관리, 프로젝트 관리 요구사항
- 품질 요구사항 : 가용성, 정합성, 상호 호환성, 대응성, 이식성, 확장성, 보안성

## 4. 사용자 요구사항(User Requirements)
- 사용자 관점에서 본 시스템이 제공해야 할 요구사항
- 사용자를 위한 것이므로 친숙한 표현으로 이해하기 쉽게 작성

## 5. 시스템 요구사항(System Requirements)
- 개발자 관점에서 본 시스템 전체가 제공해야 할 요구사항
- 전문적이고 기술적인 용어로 표현
- = 소프트웨어 요구사항

# SECTION 7. 요구사항 개발 프로세스

---

# 1. 요구사항 개발 프로세스
- 요구사항을 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 활동
- 요구사항 개발 프로세스 전에 타당성 조사(Feasibility Study)가 선행되어야 함
- 요구공학(Requirement Engineering)의 한 요소

## 1-1. 요구사항 도출(Requirement Elicitation, 요구사항 수집)
- 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 어떻게 수집할 것인지를 식별하고 이해하는 과정
- 개발자와 고객 사이의 관계가 만들어지고 이해관계자가 식별
- 소프트웨어 개발 생명 주기(SDLC) 동안 지속적으로 반복

### ✔️ 요구사항을 도출하는 주요 기법
- 청취와 인터뷰
- 설문
- 브레인스토밍
- 워크샵
- 프로토타이핑
- 유스케이스

### 1-2. 요구사항 분석(Requirement Analysis)
- 요구사항 중 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
- 요구사항의 타당성을 조사하고 비용과 일정에 대한 제약을 설정
- 서로 상충되는 요구사항이 있으면 이를 중재하는 과정
- 요구사항 분석에 사용되는 대표적인 도구 : 자료 흐름도(DFD), 자료 사전(DD)

### 1-3. 요구사항 명세(Requirement Specification)
- 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것
- 기능 요구사항을 빠짐없이 기술
- 비기능 요구사항은 필요한 것만 기술
- 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 사용될 수 있다.

### 1-4. 요구사항 확인(Requirement Validation, 요구사항 검증)
- 요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동
- 이해관계자들이 검토해야 함
- 요구사항 관리 도구를 이용하여 요구사항 정의 문서들에 대해 형상 관리(SCM)를 수행

## 2. 요구공학(Requirements Engineering)
- 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문
- 요구사항 변경의 원인과 처리 방법을 이해하고 요구사항 관리 프로세스의 품질을 개선하여 소프트웨어 프로젝트 실패를 최소화하는 것을 목표로 함

## 3. 요구사항 명세 기법
|구분|정형 명세 기법|비정형 명세 기법|
|----|-------------|---------------|
|기법|수학적 원리 기반, 모델 기반|상태/기능/객체 중심|
|작성 방법|수학적 기호, 정형화된 표기법|일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성|
|특징|요구사항을 정확하고 간결하게 표현 가능, 결과가 작성자에 관계없이 일관성이 있으므로 완전성 검증이 가능, 표기법이 어려워 사용자가 이해하기 어려움|자연어의 사용으로 인해 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고 해석이 달라질 수 있음, 내용의 이해가 쉬워 의사소통이 용이|
|종류|VDM, Z, Petri-net CSP 등|FSM, Decision Table, ER모델링, State Chart(SADT) 등|

# SECTION 8. 요구사항 분석

---

## 1. 요구사항 분석
- 소프트웨어 개발의 실제적인 첫 단계
- 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화하는 활동
- 사용자 요구의 타당성을 조사하고 비용과 일정에 대한 제약 설정
- 사용자의 요구를 정확하게 추출하여 목표를 정한다

## 2. 구조적 분석 기법
- 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법
- 도형 중심의 분석용 도구와 분석 절차를 이용하여 사용자의 요구사항을 분석하고 문서화
- **하향식 방법**을 사용하여 시스템 세분화
- 분석의 **중복 배제 가능**
- 분석 기법 도구 : 자료 흐름도(DFD), 자료 사전(DD), 소단위 명세서(Mini-Spec.), 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서

## 3. 자료 흐름도(DFD, Data Flow Diagram)
- 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법
- = 자료 흐름 그래프 = 버블 차트
- 자료 흐름과 처리를 중심으로 하는 구조적 분석 기법에 이용

## 4. 자료 흐름도 기본 기호

![](https://velog.velcdn.com/images/chs122/post/ad7ca8ce-587d-442d-8818-48429ffca6a0/image.png)
- 출처 : https://velog.io/@chs122/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EB%B6%84%EC%84%9D

## 5. 자료 사전(DD, Data Dictionary)
- 자료 흐름도에 있는 자료를 정의하고 기록한 것
- 데이터를 설명하는 데이터
- = 데이터의 데이터 = 메타 데이터
- 자료 사전에서 사용되는 표기 기호
- ![](https://t1.daumcdn.net/cfile/tistory/2258E840570C401032)
- 출처 : https://colomy.tistory.com/122

# SECTION 9. 요구사항 분석 CASE와 HIPO

---

## 1. 요구사항 분석용 CASE(자동화 도구)
- 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구

### ✔️ 대표적인 요구사항 분석용 CASE
- SADT : 시스템 정의, 소프트웨어 요구사항 분석, 시스템 및 소프트웨어 설계를 위한 도구 / SoftTech 사에서 개발 / 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구
- SREM = RSL/REVS : TRW사가 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발된 도구, RSL과 REVS를 사용하는 자동화 도구
- PSL/PSA : PSL과 PSA를 사용하는 자동화 도구, 미시간 대학에서 개발
- TAGS : 시스템 공학 방법 응용에 대한 자동 접근 방법, 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구

## 2. HIPO(Hierarchy Input Process Output)
- 시스템 실행 과정인 입력/처리/출력 기능을 표현한 것
- 하향식 소프트웨어 개발을 위한 문서화 도구
- 기능과 자료의 의존 관계를 동시에 표현
- 기호, 도표 등을 사용하므로 보기 쉽고 이해하기 쉬움
- HIPO Chart : 시스템 기능을 여러 개 고유 모듈로 분할하여 이들 간 인터페이스를 계층 구조로 표현한 것

### ✔️ HIPO Chart 종류
- 가시적 도표(Visual Table of Contents, 도식 목차)
- 총체적 도표(Overview Diagram, 총괄 도표, 개요 도표)
- 세부적 도표(Detail Diagram, 상세 도표)

# SECTION 10. UML(Unified Modeling Language) 개요

---

## 1. UML
- 시스템 개발 과정에서 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
- Rumbaugh(OMT), Boch, Jacobson 등 객체지향 방법론의 장점 통합
- OMG(Object Management Group)에서 표준으로 지정
- 구성 요소 : 사물(Things), 관계(Relationship), 다이어그램(Diagram)

## 2. 사물
- 다이어그램 안에서 관계가 형성될 수 있는 대상들

### ✔️ 사물의 종류
- 구조 사물(Structural Things) : 시스템의 개념적, 물리적 요소를 표현 / 클래스, 유스케이스, 컴포넌트, 노드 등
- 행동 사물(Behavioral Things) : 시간과 공간에 따른 요소들의 행위를 표현 / 상호작용, 상태 머신 등
- 그룹 사물(Grouping Things) : 요소들을 그룹으로 묶어서 표현 / 패키지
- 주해 사물(Annotation Things) : 부가적인 설명이나 제약조건 등을 표현 / 노트(Note)

# SECTION 11. UML - 관계(Relationship)

---

 ## 1. 관계
 - 사물과 사물 사이의 연관성을 표현
 - 관계의 종류 : 연관, 집합, 포함, 일반화, 의존, 실체화

 ## 2. 연관 관계
 - 2개의 사물이 서로 관련되어 있는 관계
 - 실선으로 표현
 - 방향성은 화살표로
 - 양방향 관계는 화살표 생략, 실선으로만 연결
 - 다중도를 선 위에 표기

 |다중도|의미|
 |-----|-----------------------|
 |1|1개의 객체가 연관되어 있음|
 |n|n개의 객체가 연관되어 있음|
 |0..1|연관된 객체가 없거나 1개만 존재|
 |0..* 또는 *|연관된 객체가 없거나 다수일 수 있음|
 |1..*|연관된 객체가 적어도 1개 이상|
 |n..*|연관된 객체가 적어도 n개 이상|
 |n..m|연관된 객체가 최소 n개에서 최대 m개|
 
 ## 3. 집합(Aggregation) 관계
 - 하나의 사물이 다른 사물에 포함되어 있는 관계
 - 포함하는 쪽과 포함되는 쪽은 서로 독립적
 - 포함되는 쪽에서 포함하는 쪽으로 속이 빈 마름모로 연결

 ## 4. 포함(Composition) 관계
 - 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
 - 포함하는 쪽과 포함되는쪽은 서로 독립될 수 없고 생명주기를 함께 함
 - 포함되는 쪽에서 포함하는 쪽으로 속이 채워진 마름모를 연결

 ## 5. 일반화 관계
 - 하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계
 - 보다 일반적인 개념을 상위(부모), 보다 구체적인 개념을 하위(자식)라고 부름
 - 구체적(하위)인 사물에서 일반적(상위) 사물쪽으로 속이 빈 화살표로 연결

 ## 6. 의존 관계
 - 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
 - 하나의 사물과 다른 사물이 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계
 - 영향을 주는 사물(이용자)이 영향을 받는 사물(제공자) 쪽으로 점선 화살표를 연결하여 표현

 ## 7. 실체화(Realization)
 - 할 수 있거나 해야 하는 기능으로, 서로 그룹화 할 수 있는 관계
 - 사물에서 기능쪽으로 속이 빈 점선 화살표를 연결하여 표현

# SECTION 12. UML - 다이어그램(Diagram)

---

## 1. 다이어그램(Diagram)

- 사물과 관계를 도형으로 표현
- 여러 관점에서 시스템을 가시화한 뷰(view)를 제공함으로써 의사소통에 도움
- 정적 모델링에서는 주로 구조적 다이어그램 사용
- 동적 모델링에서는 주로 행위 다이어그램 사용

## 2. 구조적 다이어그램 종류

### 2-1. 클래스 다이어그램
- 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현

### 2-2. 객체 다이어그램 (Object Diagram)
- 클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
- 럼바우 객체 지향 분석 기법에서 객체 모델링에 활용

### 2-3. 컴포넌트 다이어그램
- 컴포넌트 간의 관계나 인터페이스 표현
- **구현 단계에서 사용**

### 2-4. 배치 다이어그램(Deployment Diagram)
- 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
- **구현 단계에서 사용**

### 2-5. 복합체 구조 다이어그램(Composite Structure Diagram)
- 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현

### 2-6. 패키지 다이어그램
- 유즈케이스나 클래스 등의 모델 요소들을 그룹화한 패키지 간 관계를 표현

## 3. 행위 다이어그램의 종류

## 3-1. 유스케이스 다이어그램
- 사용자의 요구를 분석하는 것
- 기능 모델링 작업에 사용
- 사용자와 사용 사례로 구성

### 3-2. 시퀀스 다이어그램
- 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현

### 3-3. 커뮤니케이션 다이어그램
- 동작에 참여하는 객체들이 주고받는 메시지와 객체들 간 연관관계 표현

### 3-4. 상태 다이어그램
- 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 변하는 상태를 표현
- 럼바우 객체지향 분석 기법에서 동적 모델링에 활용

### 3-5. 활동 다이어그램
- 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현

### 3-6. 상호작용 개요 다이어그램(Interaction Overview Diagram)
- 상호작용 다이어그램 간 제어 흐름 표현

### 3-7. 타이밍 다이어그램(Timing Diagram)
- 객체 상태 변화와 시간 제약을 명시적으로 표현

## 4. 스테레오 타입
- UML에서 표현하는 기본 기능 외에 **추가적인 기능을 표현하는 것**
- 길러멧으로 불리는 겹화살괄호(<<>>) 사이에 표현할 형태를 기술
- <\<include>> : 연결된 다른 UML 요소에 대해 포함 관계
- <\<extends>> : 연결된 다른 UML 요소에 대해 확장 관계
- <\<interface>> : 인터페이스 정의
- <\<exception>> : 예외를 정의
- <\<constructor>> : 생성자 역할을 수행

# SECTION 13. 유스케이스 다이어그램

---

## 1. 기능 모델링
- 개발될 시스템이 갖춰야 할 기능을 정리한 후 사용자와 내용을 공유하기 위해 **그림으로 표현**
- 전반적인 형태를 기능에 초점을 맞춰 표현
- 종류 : 유스케이스 다이어그램, 액티비티 다이어그램

## 2. 유스케이스 다이어그램
- **개발될 시스템을 이용해 수행할 수 있는 기능을 사용자 관점에서 표현한 것**
- 외부 요소와 시스템 간의 상호 작용 확인 가능
- 사용자의 요구사항을 분석하기 위한 도구로 사용
- 시스템의 범위 파악 가능

## 3. 유스케이스 다이어그램의 구성요소

|구성요소|표현 방법|내용|
|-------|---------|-------|
|시스템 / 시스템 범위|상자|시스템 내부의 유스케이스들을 사각형으로 묶어 시스템 범위를 표현한 것|
|액터|주액터-사람, 부액터-<<>>와 상자|시스템과 상호작용을 하는 모든 요소, 주로 사람이나 외부 시스템, 주액터(시스템을 사용함으로써 이득을 얻는 대상, 주로 사람), 부액터(주액터 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템, 조직이나 기관)|
|유스케이스|동그라미|사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스나 기능을 표현한 것|
|관계|포함-<\<include>>점선화살표, 확장-<\<extends>>점선 화살표, 일반화-속이빈 화살표|액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타남|

# SECTION 14. 활동 다이어그램

---

## 1. 활동 다이어그램
- **사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것**
- 하나의 유스케이스 안에서 혹은 유스케이스 사이에 발생하는 복잡한 처리의 흐름을 명확하게 표현 가능
- 자료흐름도와 유사

## 2. 활동 다이어그램 구성요소
|구성요소|표현 방법|내용|
|-------|---------|---------|
|액션/액티비티|모서리 둥근 네모|액션 : 더 이상 분해할 수 없는 단일 작업, 액티비티 : 몇 개의 액션으로 분리될 수 있는 작업|
|시작노드|속이 채워진 동그라미|액션이나 액티비티가 시작됨|
|종료노드|속이 채워진 동그라미 바깥쪽에 선이 하나 더|액티비티 안의 모든 흐름 종료|
|조건(판단) 노드|위아래로 화살표가 연결되는 마름모|조건에 따라 제어의 흐름이 분리, 들어오는 제어 흐름은 하나이고 나가는 제어 흐름은 여러 개|
|병합 노드|왼쪽오른쪽으로 화살표가 연결되는 마름모|여러 경로의 흐름이 하나로 합쳐짐을 표현, 들어오는 제어 흐름은 여러 개고 나가는 흐름은 하나|
|포크 노드|들어오는 화살표 하나 나가는 화살표 여러개|액티비티 흐름이 분리되어 수행됨|
|조인 노드|들어오는 화살표 여러개 나가는 화살표 하나|분리되어 수행되던 액티비티의 흐름이 다시 합쳐짐|
|스윔레임|\||액티비티 수행을 담당하는 주체를 구분, 가로 또는 세로 실선을 그어 구분|

# SECTION 15. 클래스 다이어그램

---

## 1. 정적 모델링
- **사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것**
- 시스템에 의해 처리되거나 생성될 객체들 사이에 어떤 관련이 있는지를 구조적인 관점에서 표현
- 객체들을 클래스로 추상화하여 표현
- UML을 이용한 정적 모델링의 대표적인 것이 클래스 다이어그램

## 2. 클래스 다이어그램
- 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 것
- 시스템을 구성하는 요소에 대해 이해 가능한 구조적 다이어그램
- 시스템 구성요소를 문서화하는데 사용

## 3. 클래스 다이어그램의 구성요소
|구성요소|표현방법|내용|
|------|--------|---------|
|클래스|표형태|각가의 객체들이 갖는 속성과 오퍼레이션(동작, 메소드)을 표현, 일반적으로 3개의 구획을 나눠 클래스 이름과 속성과 오퍼레이션 표기, 속성(클래스 상태나 정보)|
|제약조건|메모형태|속성에 입력될 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건, 클래스 안에 제약조건 기술시 중괄호 이용|
|관계|선|클래스 다이어그램에 표현하는 관계에는 연관, 집합, 포함, 일반화, 의존 관계가 있음|

## 4. 연관 클래스
- 연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스
- 두 클래스의 연관관계를 나타내는 선의 가운데로부터 점선을 연관 클래스로 이어 표시
- 이름은 연관 관계의 이름을 이용해 지정

# SECTION 16. 시퀀스 다이어그램

---

## 1. 동적 모델링
- **시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현한 것**
- 시스템 내부 구성 요소들 간 이뤄지는 동작이라는 관점에서 표현
- 시스템이 실행될 때 구성 요소들 간 메시지 호출, 즉 오퍼레이션을 통한 상호 작용에 초점
- 종류 : 시퀀스 다이어그램, 커뮤니케이션 다이어그램, 상태 다이어그램

## 2. 시퀀스 다이어그램
- **시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현한 것**
- 각 동작에 참여하는 시스템이나 객체들의 수행 기간 확인 가능
- 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호작용을 표현

## 3. 시퀀스 다이어그램의 구성 요소
|구성요소|표현방법|의미|
|-------|------------|--------------|
|액터|사람|시스템으로부터 서비스를 요청하는 외부요소, 사람이나 외부 시스템|
|객체|네모|메시지를 주고받는 주체|
|생명선|점선|객체가 메모리에 존재하는 기간, 객체 아래쪽에 점선을 그어 표현, 객체 소멸(X)이 표시된 기간까지 존재|
|실행 상자(Active Box, 활성 상자)|긴 상자|객체가 메시지를 주고 받으며 구동되고 있음을 표현|
|메시지|화살표|객체가 상호 작용을 위해 주고받는 메시지|
|객체 소멸|X|해당 객체가 더 이상 메모리에 존재하지 않음을 표현|
|프레임|상자와 상자 왼쪽 상단에 이름 있음|다이어그램의 전체 또는 일부를 묶어 표현|

# SECTION 17. 커뮤니케이션 다이어그램

---

## 1. 커뮤니케이션 다이어그램
- **동작에 참여하는 개체들이 주고받는 메시지와 객체들 간 연관관계 표현**
- 객체들 사이 관계 파악
- 클래스 다이어그램에서 관계가 제대로 표현됐는지 점검하는 용도로도 사용됨
- 초기에는 협업 다이어그램으로 불림
- 시퀀스 다이어그램과 구별되는 가장 큰 특징은 메시지 뿐만 아니라 객체들 간 관계까지 표현한다는 것

## 2. 커뮤니케이션 다이어그램의 구성 요소
|구성요소|표현방법|의미|
|-------|----------|-------------|
|액터|사람|시스템으로부터 서비스를 요청하는 외부 요소, 사람이나 외부 시스템을 의미|
|객체|네모|메시지를 주고받는 주체|
|링크|실선|객체들 간 관계|
|메시지|속이 꽉찬 실선 화살표|객체가 상호작용을 위해 주고받는 내용, 화살표 방향은 메시지를 받는 쪽으로, 일정한 순서에 처리되는 메시지는 숫자로 순서 표현|

# SECTION 18. 상태 다이어그램

---

## 1. 상태 다이어그램
- **객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현한 것**
- 객체의 상태 : 객체가 갖는 속성 값의 변화
- 시스템에서 상태 변환 이벤트를 확인할 필요가 있는 객체만을 대상으로 함

## 2. 상태 다이어그램의 구성 요소
|구성요소|표현방법|의미|
|-----|----------|----------|
|상태|모서리가 둥근 사각형|객체의 상태를 표현한 것|
|시작상태|속이 채워진 동그라미|상태의 시작을 표현한 것|
|종료상태|속이 채워진 동그라미 바깥쪽에 선이 하나 더|상태의 종료를 표현한 것|
|상태 전환|속이 채워진 실선 화살표|상태의 흐름, 변화를 표현|
|이벤트|글씨|상태에 변화를 주는 현상, 이벤트에는 조건-외부신호-시간의 흐름 등이 있음|
|프레임|상자와 상자 왼쪽 상단에 이름 있음|상태 다이어그램의 범위를 표현한 것|

# SECTION 19. 패키지 다이어그램

---

## 1. 패키지 다이어그램
- 유스케이스나 클래스 등의 요소들을 그룹화한 패키지 간 의존 관계를 표현한 것
- 패키지는 또 다른 패키지의 요소가 될 수 있음

## 2. 패키지 다이어그램의 구성 요소
|구성요소|표현방법|의미|
|-----|---------|----------|
|패키지|큰 상자 왼쪽 상단 위에 작은 상자|객체들을 그룹화, 단순 표기법 : 패키지 안에 패키지 이름만 표현, 확장 표기법 : 패키지 안의 요소까지 표현|
|객체|네모|유스케이스, 클래스, 인터페이스, 테이블 등 패키지에 포함될 수 있는 다양한 요소들|
|의존 관계|점선 화살표|스테레오타입을 이용해 의존 관계 구체화 가능, 의존 관계의 표현형태는 사용자가 임의로 작성 가능 - 대표적으로 import와 access가 사용됨. <\<import>> : 패키지에 포함된 객체들을 직접 가져와서 이용하는 관계, <\<access>> : 인터페이스를 통해 패키지 내의 객체에 접근하여 이용하는 관계|

# SECTION 20. 소프트웨어 개발 방법론

---

## 1. 소프트웨어 개발 방법론
- **소프트웨어 개발, 유지보수 등에 필요한 수행방법과 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것**
- 목적 : 소프트웨어의 생산성과 품질 향상

## ✅ 주요 소프트웨어 개발 방법론

### 1-2. 구조적 방법론
- 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론
- 60년대까지 많이 적용되었던 방법론
- 쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적
- 복잡한 문제를 다루기 위해 분할과 정복 원리를 적용
- 구조적 방법론의 개발 절차 : 타당성 검토 -> 계획 -> 요구사항 -> 설계 -> 구현 -> 시험 -> 운용/유지보수

### 1-3. 정보공학 방법론
- 계획, 분석, 설계, 구축에 정형화된 기법들을 통합 및 적용하는 자료 중심의 방법론
- 정보 시스템 개발 주기를 이용하여 대규모 정보 시스템을 구축하는데 적합
- 절차 : 정보 전략 계획 수립 -> 업무 영역 분석 -> 업무 시스템 설계 -> 업무 시스템 구축

### 1-4. 객체지향 방법론
- 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론
- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택
- 구성 요소 : 객체, 클래스 메시지 등
- 기본 원칙 : 캡슐화, 정보 은닉, 추상화, 상속성, 다형성 등
- 절차 : 요구 분석 -> 설계 -> 구현 -> 테스트 및 검증 -> 인도

### 1-5. 컴포넌트 기반(CBD, Component Based Design) 방법론
- 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론
- 재사용이 가능하여 시간과 노력을 절감
- 새로운 기능을 추가하는 것이 간단해 확장성이 보장
- 유지보수 비용을 최소화하고 생산성 및 품질 향상 가능
- 절차 : 개발 준비 -> 분석 -> 설계 -> 구현 -> 테스트 -> 전개 -> 인도

### 1-6. 제품 계열 방법론
- 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
- 임베디드 소프트웨어를 만드는데 적합
- 영역공학과 응용공학으로 구분
- 영역공학 : 영역분석, 영역설계, 핵심 자산을 구현하는 영역
- 응용공학 : 제품 요구 분석, 제품 설계, 제품을 구현하는 영역
- 영역공학과 응용공학의 연계를 위해 제품의 요구사항, 아키텍처, 조립 생산이 필요

# SECTION 21. SW 공학의 발전적 추세

---

## 1. 소프트웨어 재사용
- 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것
- 소프트웨어 개발의 품질과 생산성을 높이기 위한 방법
- 기존에 개발된 소프트웨어와 경험, 지식 등을 새로운 소프트웨어에 적용

### ✔️ 소프트웨어 재사용 방법
- 합성 중심(Composition-Based) : 전자 칩과 같은 소프트웨어 부품, 즉 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법, (= 블록 구성 방법)
- 생성 중심(Generation-Based) : 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법으로, (=패턴 구성 방법)

## 2. 소프트웨어 재공학
- 기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것
- 유지보수 비용이 소프트웨어 개발 비용의 대부분을 차지하므로 유지보수의 생산성 향상을 통해 소프트웨어 위기를 해결
- 이점 : 품질 향상, 생산성 증가, 수명 연장, 오류 감소

## 3. CASE(Computer Aided Software Engineering)
- 소프트웨어 개발 과정에서 사용되는 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것
- 객체지향 시스템, 구조적 시스템 등 다양한 시스템에서 활용되는 자동화 도구(CASE Tool)
- 소프트웨어 생명 주기의 전체 단계를 연결하고 자동화하는 통합 도구를 제공
- 소프트웨어 개발 도구와 방법론이 결합되었으며, 정형화된 구조 및 방법을 소프트웨어 개발에 적용하여 생산성 향상을 구현
- 주요 기능 : 소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원

# SECTION 22. 비용 산정 기법

---

## 1. 소프트웨어 비용 산정
- 개발에 소요되는 인원, 자원, 기간 등으로 소프트웨어 규모를 확인하여 개발 계획 수립에 필요한 비용을 산정하는 것
- 비용 너무 높게 산정할 경우 : 예산 낭비, 일의 효율성 저하 초래
- 비용 너무 낮게 산정할 경우 : 개발자의 부담이 가중, 품질 문제
- 기법에는 하향식 비용 산정 기법과 상향식 비용 산정 기법이 있다.

## 2. 소프트웨어 비용 결정 요소

### 2-1. 프로젝트 요소
- 제품 복잡도 : 소프트웨어 종류에 따라 발생할 수 있는 문제점들의 난이도
- 시스템 크기 : 소프트웨어 규모에 따라 개발해야 할 시스템의 크기
- 요구되는 신뢰도 : 일정 기간 내 주어진 조건 하에서 프로그램이 필요한 기능을 수행하는 정도

### 2-2. 자원 요소
- 인적 자원 : 소프트웨어 개발 관련자들이 갖춘 능력 혹은 자질
- 하드웨어 자원 : 소프트웨어 개발 시 필요한 보조 장비
- 소프트웨어 자원 : 소프트웨어 개발 시 필요한 개발 지원 도구

### 2-3. 생산성 요소
- 개발자 능력 : 개발자들이 갖춘 전문지식, 경험, 이해도, 책임감, 창의력 등
- 개발 기간 : 소프트웨어를 개발하는 기간

# SECTION 23. 비용 산정 기법 - 하향식

---

## 1. 하향식 비용 산정 기법
- 과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 비과학적인 방법
- 프로젝트의 전체 비용을 산정한 후 각 작업별로 비용을 세분화
- 전문가 감정 기법, 델파이 기법

## 2. 전문가 감정 기법
- 경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법
- 가장 편리하고 신속하게 비용 산정 가능
- 의뢰자로부터 믿음을 얻을 수 있음
- 개인적이고 주관적일 수 있음

## 3. 델파이 기법
- 전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법
- 전문가들의 편견이나 분위기에 지배되지 않도록 한 명의 조정자와 여러 전문가로 구성된다.

# SECTION 24. 비용 산정 기법 - 상향식

---

## 1. 상향식 비용 산정 기법
- 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법
- 주요 기법 : LOC(원시 코드 라인 수) 기법, 개발 단계별 인월수 기법, 수학적 산정 기법

## 2. LOC(원시 코드 라인 수, source Line Of Code) 기법
- 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하고 비용을 산정하는 기법
- 측정이 용이하고 이해하기 쉬워 가장 많이 사용됨
- 예측치를 이용하여 생산성, 노력, 개발 기간 등의 비용 산정
$$예측치 = \frac{a+4m+b}{6} a = 낙관치, b = 비관치, c = 기대치(중간치)$$
- 산정 공식
    - 노력(인월) =  개발 기간 x 투입 인원 = LOC / 1인당 월평균 생산코드 라인 수
    - 개발 비용 = 노력(인월) x 단위 비용(1인당 월평균 인건비)
    - 개발 기간 = 노력(인월) / 투입 인원
    - 생산성 = LOC / 노력(인월)

## 3. 개발 단계별 인월수(Effort Per Task) 기법
- LOC 기법을 보완하기 위한 기법으로 각 **기능을 구현시키는 데 필요한 노력을 생명주기의 각 단계별로 산정**





