---
layout: post  
title: "[자료구조] 6장. 연결된 구조"
date: 2022-10-25
excerpt: "파이썬으로 쉽게 풀어쓴 자료구조 6장을 정리한 내용입니다"
tag:
- 자료구조
comments: true
--- 

# 6.1 연결된 구조란?

---

## ✅ 연결된 구조는 흩어진 데이터를 링크로 연결해서 관리

- 연결된 구조(linked structure) : 항목들을 링크로 연결하여 표현하는 방법
- 연결 리스트 : 항목들을 링크를 통해 일렬로 나열할 수 있는 연결된 구조
- 노드 : 하나의 상자, 데이터와 함께 링크를 가짐
- 연결된 구조에서 링크 수를 늘리면 선형 자료구조 뿐 아니라 트리나 그래프와 같이 더 복잡한 구조도 효율적으로 표현 가능
- 배열구조처럼 k번째 항목의 주소를 계산해서 바로 찾아갈 수 없음에 유의, 시작 항목에서부터 링크를 따라 각 항목을 하나씩 찾아가야 함

## ✅ 배열구조와 연결된 구조의 장단점

### ✔️ 연결된 구조의 장점
- 용량이 고정되지 않고 필요한만큼만 할당해 사용하며, 크기 제한도 없음
- 배열은 무턱대고 크게 할당해놓으면 메모리 낭비가 심하고, 적게 할당하면 더 필요한 경우 문제가 된다.
- 중간에 자료를 삽입하거나 삭제하는 것이 용이 -> 링크만 수정하면 되므로 시간복잡도가 O(1)

### ✔️ 연결된 구조의 단점
- n번째 항목에 접근하는데 O(n)의 시간이 걸림 (배열은 접근의 경우 O(1))
- 배열에 비해 상대적으로 구현이 어렵고 오류 발생하기 쉬움

## ✅ 연결 리스트의 구조

### ✔️ 노드
- 데이터 필드와 함께 하나 이상의 링크 필드를 갖는다.
- 데이터 필드 : 저장하고 싶은 데이터(정수, 클래스의 객체, 다른 리스트 등)
- 링크 필드 : 다른 노드를 가리키는, 즉 다른 노드의 주소를 저장하는 변수

### ✔️ 헤드 포인터
- 연결 리스트는 첫 번째 노드만 알면 링크로 매달려 있는 모든 노드에 순차적으로 접근 가능
- **시작 노드의 주소를 반드시 저장해야 함**
- 헤드 포인터 : 연결 리스트에서 첫 번째 노드의 주소를 저장하는 변수
- cf) 마지막 노드는 더 이상 연결할 노드가 없기 때문에 링크 값을 None으로 설정

## ✅ 연결 리스트의 종류

### ✔️ 단순 연결 리스트(singly linked list)
- 하나의 방향으로만 연결되어 있는 구조
- 링크 개수 하나, 다음 노드의 주소를 기억
- 마지막 노드의 링크는 아무것도 연결되어 있지 않다는 의미의 None 값을 가짐

### ✔️ 원형 연결 리스트(circular linked list)
- 단순연결리스트와 동일한 노드 구조를 사용하지만 맨 마지막 노드의 링크 값이 None이 아니라 다시 첫 번째 노드를 가리킴
- 노드를 순서대로 방문할 때 종료조건에 유의해야 함

### ✔️ 이중 연결 리스트(doubly linked list)
- 하나의 노드가 이전 노드와 다음 노드를 모두 알 수 있도록 설계
- 하나는 선행 노드(previous node), 다른 하나는 후속 노드(next node)
- 어떤 노드에서 이전 노드를 바로 찾아갈 수 있다는 장점
- 이중으로 링크를 정확히 유지해야 하므로 코드가 복잡해진다.

![](https://user-images.githubusercontent.com/77424107/197584699-27bcad1d-f690-4fb3-8116-282c4c7e44c9.png)

# 6.2 단순연결리스트 응용 : 연결된 스택

---

- 헤드 포인터를 스택의 top으로 사용하면 됨

## ✅ 노드 클래스
- 단순연결리스트를 위한 노드 클래스
- 링크는 디폴트 인수 기능을 이용해 인수가 전달되지 않으면 None으로 초기화됨

## ✅ 연결된 스택 클래스
- 데이터 멤버로는 시작노드를 가리키는 변수 top만 있으면 됨
- 스택의 공백 상태 : top이 None을 가리키면 됨

### ✔️ push(E) 삽입 연산
- 데이터를 넣을 새로운 노드를 만들고 이 노드를 스택의 top에 추가해야 함

#### ⭐ 삽입연산 단계
- 1. 입력데이터 E를 리용해 새로운 노드 n을 생성 : n - Node(E)
- n의 링크가 시작노드를 가리키도록 함 : n.link = top
- top이 n을 가리키도록 함 : top = n

![](https://user-images.githubusercontent.com/77424107/197775741-034c1453-f3a2-4790-bab3-08c1d4f6272a.png

### ✔️ pop() 삭제연산
- top이 가리키는 노드를 꺼내고 데이터 필드만을 반환
- 공백상태를 반드시 검사해야 함
- 공백이 아니면 top이 가리키는 노드를 꺼내고 데이터 필드를 반환
- 노드가 아닌 스택 항목을 반환해야 함
- 메모리 해제를 신경 쓸 필요 없음(파이썬에서는 어떤 객체를 참조하는 변수가 하나라도 없으면 그 객체는 자동으로 삭제됨)

#### ⭐ 삭제연산 단계
- 1. 변수 n이 시작노드를 가리키도록 함 : n = top
- 2. top이 다음노드를 가리키도록 함 : top = n.link
- 3. n이 가리키는 노드의 데이터를 반환 return n.data

![](https://user-images.githubusercontent.com/77424107/197776912-d60a75b6-cc81-4998-86bf-2c6eb7742968.png)


### ✔️ peek()
- 공백 상태가 아니면 시작노드의 데이터를 반환하면 됨

### ✔️ size()
- 연결된 구조에서는 스택 항목 수가 어려움
- 왜냐하면 링크를 따라 맨 마지막까지 움직여보기 전까지는 몇 개의 노드들이 매달려 있는지 알 수 없음.

### ✔️ display()
- 모든 노드의 데이터 출력을 위해서는 모든 노드를 방문해야 함

- cf) node = node.link # 다음 노드로 이동
- cf) return node.data # 항목의 데이터 반환

## ✅ 시간복잡도
- 삽입과 삭제 모두 O(1) (배열에서는 삽입할 때 리스트가 용량을 증가해야 하면 O(n))
- size는 배열에서는 O(1)이지만 스택에서는 O(n) 

# 6.3 단순연결리스트 응용 : 연결된 리스트

---

- 변수 head가 시작노드를 가리키도록 하고, 마지막 노드의 링크는 None을 가짐

## ✅ 노드 클래스
- 연결된 스택과 동일

## ✅ 연결 리스트 클래스
- 데이터 멤버는 헤드 포인터인 head만으로 충분
- 공백상태는 head가 None인지 검사
- 초기화는 self.head = None으로

### ✔️ getNode(pos) : pos번째 노드 반환
- head부터 시작해서 링크를 따라 순서적으로 찾아서 해당 노드 반환하면 됨
- 시간복잡도 O(n)

### ✔️ getEntry(pos) 
- 연산이 구현되면 항목의 데이터만을 반환하는 함수
- 시간복잡도 O(n)

### ✔️ replace(pos, elem)
- 어떤 위치의 항목을 다른 데이터로 변경하는 연산
- pos번째 노드를 찾아 데이터 필드에 elem 복사

### ✔️ find(val)
- 원하는 데이터를 가진 노드를 찾는 함수도 비교적 간단

### ✔️ insert(pos, elem) : 삽입 연산
- pos 위치의 노드가 아니라 그 이전노드 before의 링크 값이 수정 = pos 위치에 새로운 노드를 삽입하려면 그 노드의 선행 노드를 알아야 함
- before을 알고 있다면 삽입은 O(1)
- before을 찾아야 한다면 O(n)

#### ⭐ 삽입 단계
![](https://user-images.githubusercontent.com/77424107/197792968-7e89e1ab-e695-4205-ac57-2cd8a726cea7.png)

### ✔️ delete(pos) : 삭제연산
- pos 위치의 노드가 아니라 before의 노드가 필요

![](https://user-images.githubusercontent.com/77424107/197796067-8f1021d9-ea2c-4fcd-8d8d-95ea1e0c7cad.png)

# 6.4 원형연결리스트의 응용 : 연결된 큐

---

- 장점 : 크기가 제한되지 않고 필요한 메모리만 사용
- 단점 : 코드가 복잡해지고 링크 필드 때문에 메모리 공간을 조금 더 사용

## ✅ 단순연결리스트
- 맨 앞 : front (삭제)
- 맨 뒤 : rear (삽입)

## ✅ 원형연결리스트
- 마지막 노드의 링크가 첫 노드를 가리킴
- tail(rear)만을 변수로 저장
- front는 tail의 다음 노드 즉 tail.link가 front이다.
- 만약 front를 노드로 사용한다면 tail접근하기 위해 끝까지 이동해야 하므로 비효율적
- 후단은 rear==tail이고, 전단은 rear==tail.link이므로 시간복잡도 O(1)

### ✔️ 삽입 연산 : ENQUEUE()

#### ⭐ CASE 1 : 큐가 공백상태인 경우의 삽입연산
- 1. 입력 데이터 E를 이용해 새로운 노드를 생성 함 : n = Node(E, None)
- 2. n 링크가 자기 자신을 가리키도록 함 : n.link = n
- 3. tail이 n을 가리키도록 함 : tail = n

#### ⭐ CASE 2 : 큐가 공백상태가 아닌 경우의 삽입연산
- 1. 입력 데이터 E를 이용해 새로운 노드 n을 생성 : node = Node(E, None)
- 2. n의 링크가 front를 가리키도록 함 : n.link = tail.link
- 3. tail의 링크가 n을 가리키도록 함 : tail.link = n
- 4. tail이 n을 가리키도록 함 : tail = n

### ✔️ 삭제 연산 : DEQUEUE()
- front(tail.link)를 연결구조에서 꺼내고 데이터 필드를 반환하는 것
- 큐는 반드시 공백이 아니어야 삭제 가능
- 큐가 항목을 하나만 가지고 있는 경우를 삭제하고 나면 공백상태가 되므로 일반적 경우와 분리해야 함

#### ⭐ CASE 1 : 큐가 하나의 항목을 갖는 경우 삭제연산
- 1. n이 전단노드(front, tail.link)를 가리키도록 함 : n = tail.link
- 2. tail이 None을 가리키도록 함 : tail = None
- 3. n이 가리키는 노드의 데이터를 반환 : return n.data

#### ⭐ CASE 2 : 큐가 두 개 이상의 항목을 갖는 경우의 삭제연산
- 1. n이 전단노드(front)를 가리키도록 함 : n = tail.link
- 2. tail의 링크가 front의 링크를 가리키도록 함 : tail.link = n.link
- 3. n이 가리키는 노드의 데이터를 반환 : return n.data

## ✅ size(), print()
- 큐의 크기를 구하거나 큐의 내용을 출력하기 위해서는 tail부터 노드를 따라가면서 한 바퀴 돌아와야 함

# 6.5 이중연결리스트의 응용 : 연결된 덱

---

## ✅ 단순연결리스트로 구현한 덱의 문제점
- deleteRear 연산에서 rear를 앞으로 한 칸 옮겨야 하는데 rear의 선행 노드를 바로 알 수가 없어 전체 노드 탐색해야 하므로 O(n) 소요

## ✅ 이중연결리스트로 구현한 덱

### ✔️ 이중연결리스트를 위한 노드
- 데이터와 두 개의 링크(prev, next)

### ✔️ 연결된 덱 클래스

- 공백 상태 : 전단이나 후단이 None : self.front == None
- 초기화 : self.front = self.rear = None
- 전후단 삭제의 시간복잡도는 모두 O(1)

#### ⭐ addFront() : 전단 삽입
- 1. 노드 생성 및 prev, next 초기화 : n = DNode(item, None, front) (원래 front가 뒤로오도록)
- 2. 기존의 front가 선행노드로 n을 가리킴 : front.prev = n
- 3. 이제 front가 n을 가리킴 : front = n
- cf) 만약 공백이라면 front와 rear 모두 n을 가리키도록 함

#### ⭐ addRear() : 후단삽입
- 1. 노드 생성 및 prev, next 초기화 : n = DNode(item, rear, None) (원래 rear가 앞으로 오도록)
- 2. 기존의 rear가 후행노드로 n을 가리킴 : rear.next = n
- 3. 이제 rear가 n을 가리킴 : rear = n
- cf) 만약 공백이라면 front와 rear 모두 n을 가리키도록 함

#### ⭐ deleteFront() : 전단 삭제
- 1. 삭제할 노드(front)의 데이터 복사 : data = front.data
- 2. front를 다음으로 옮김 : front = front.next
- 3. 새로운 front의 이전노드는 None : front.prev = None
- 4. 데이터 반환 : return data
- cf) 만약 노드가 하나 뿐이라면 rear도 None으로 설정

#### ⭐ deleteRear() : 후단 삭제
- 1. 삭제할 노드(rear)의 데이터 복사 : data = rear.data
- 2. rear를 그 전으로 옮김 : rear = rear.prev
- 3. 새로운 rear의 후행노드는 None : rear.next = None
- 4. 데이터 반환 : return data
- cf) 만약 노드가 하나 뿐이라면 front도 None으로 


