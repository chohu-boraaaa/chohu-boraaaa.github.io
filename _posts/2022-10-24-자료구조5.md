---
layout: post  
title: "[자료구조] 5장. 큐와 덱"
date: 2022-10-24
excerpt: "파이썬으로 쉽게 풀어쓴 자료구조 5장을 정리한 내용입니다"
tag:
- 자료구조
comments: true
--- 

# 5.1 큐란?

---

## ✅ 큐는 선입선출(First-In First Out:FIFO)의 자료구조이다.
- 후단(rear) : 삽입이 일어나는 곳
- 전단(front) : 삭제가 일어나는 곳

## ✅ 큐의 추상자료형

### 데이터 
- 선입선출의 접근 방법을 유지하는 항목들의 모임

### 연산
- Queue() : 비어 있는 큐를 만든다.
- isEmpty() : 큐가 비어있으면 True, 아니면 False를 반환
- enqueue(x) : 항목 x를 큐의 맨 뒤에 추가
- dequeue() : 큐의 맨 앞에 있는 항목을 꺼내 반환
- peek() : 큐의 맨 앞에 있는 항목을 삭제하지 않고 반환
- size() : 큐의 모든 항목들의 개수 반환
- clear() : 큐를 공백상태로 만듦

## ✅ 큐의 응용
- 버퍼 : 컴퓨터에서 데이터를 주고받을 때 각 주변장치들 사이에 존재하는 속도의 차이나 시간차이를 극복하기 위한 임시 기억 장치
- 콜큐 : 콜 센터에서 사용
- 프린터와 컴퓨터 사이의 인쇄 작업 큐
- 실시간 비디오 스트리밍에서의 버퍼링
- 시뮬레이션의 대기열(공항의 비행기들, 은행에서의 대기, 인터넷에서 전송되는 데이터 패킷들의 모델링)

# 5.2 큐의 구현

---

## ✅ 선형큐의 문제점
- 삽입과 삭제 연산의 시간 복잡도를 모두 O(1)로 만들수 없어 선형큐는 비효율적이다.
- 삽입 연산 시간복잡도 : O(1)
- 삭제 연산 시간 복잡도 : 맨 앞이 삭제되면 다른 항목들을 한 칸씩 앞으로 이동시켜야 하므로 O(n)

## ✅ 원형 큐가 훨신 효율적
- 배열을 원형으로 사용
- 삽입, 삭제가 인덱스만 변형되므로 삽입과 삭제 연산이 모두 O(1)

### ✔️ 전단과 후단을 위한 2개의 변수
- front : 첫 번째 요소 하나 앞의 인덱스, 가장 최근에 삭제된 항목의 위치를 저장
- rear : 마지막 요소의 인덱스, 큐에 가장 최근에 삽입된 항목의 위치
- 맨 처음 = rear = front = 0

![](https://user-images.githubusercontent.com/77424107/197409367-3a73ffa1-8a5d-4709-ae6b-d8e0ac952791.png)

### ✔️ 회전(시계방향) 방법 : 나머지 연산자 사용
- front <- (front+1) % MAX_QSIZE
- rear <- (rear+1) % MAX_QSIZE

### ✔️ 공백상태와 포화상태
- 공백상태 : front == rear
- 포화상태 : front % MAX_QSIZE == (rear+1)%MAX_QSIZE
- 공백 상태와 포화상태를 구별하는 방법 : 하나의 공간은 항상 비워두기!

# 5.3 큐의 응용 : 너비우선탐색

---

- 파이썬의 큐 모듈은 큐와 스택 클래스를 제공

## ✅ 큐 응용 예시
- 이진트리의 레벨 순회
- 기수정렬에서의 레코드 정렬을 위해 사용
- 그래프의 탐색에서 너비우선탐색

## ✅ 미로 탐색 : 너비우선탐색(BFS)
- 출발점에서부터 인접한 위치들을 먼저 방문한 다음, 방문한 위치들에 인접한 위치들을 순서대로 찾아가는 방법. 출구를 찾거나 모든 위치를 방문할 때까지 계속 됨. 

## ✅ 파이썬의 큐 모듈

- 큐(Queue)와 스택(LifoQueue) 클래스 제공
- 사용하기 위해서는 queue 모듈 import 해야 함
- 큐 객체 생성 : Q = queue.Queue(maxsize=20) # 큐 객체 생성(최대크기 20)
- 함수 이름 변경 : 삽입은 put(), 삭제는 get()

### ✔️ 유의사항
- 공백상태의 큐에 get() 연산을 하면 언더플로 발생
- maxsize 이상의 항목을 put() 하는 경우 오버플로 발생
- get(), put() 함수는 언더플로나 오버플로가 발생하더라도 에러를 반환하지 않고, 단순히 무한루프에 빠지게 되는 것에 유의 -> 연산 처리 전에 empty()와 full()을 이용해 큐 상태를 먼저 확인하는 것이 안전

# 5.4 덱(DEQUE)이란?

---

## ✅ 덱은 스택이나 큐보다는 입출력이 자유로운 자료구조

- double-ended queue
- 큐의 전단(front)과 후단(rear)에서 모두 삽입과 삭제가 가능한 큐

![](https://user-images.githubusercontent.com/77424107/197547947-9838e573-48a5-4ec6-bd4e-f00478e033c3.png)

## ✅ 추상 자료형

### 데이터
- 전단과 후단을 통한 접근을 허용하는 항목들의 모임

### 연산
- Deque() : 비어 있는 덱 만들기
- isEmpty() : 덱이 비어있으면 True, 아니면 False
- addFront(x) : 항목 x를 덱의 맨 앞에 추가
- deleteFront() : 맨 앞의 항목 꺼내서 반환
- getFront() : 맨 앞 항목 꺼내지 않고 반환
- addRear(x) : 맨 뒤의 항목 꺼내서 반환
- deleteRear() : 맨 뒤의 항목을 꺼내서 반환
- getRear() : 맨 뒤의 항목을 꺼내지 않고 반환
- isFull() : 덱이 가득 차 있으면 True를 아니면 False를 반환
- size() : 덱의 모든 항목들의 개수 반환
- clear() : 덱을 공백상태로 만듦

## ✅ 원형 덱의 연산
- 큐와 데이터는 동일
- 연산은 유사
- 큐와 비슷한 점 : addRear = enqueue, deleteFront = dequeue, getFront = peek
- 스택과 비슷한 점 : addRear = push, deleteRear = pop, getRear = peek

## ✅ 원형 덱이 원형 큐에서 추가한 연산

### ✔️ 반시계방향 회전 필요
- front <- (front-1 + MAX_QSIZE) % MAX_QSIZE
- rear <- (rear-1) + (MAX_QSZIE) % MAX_QSIZE

# 5.5 덱의 구현

---

## ✅ 원형 큐를 상속하여 원형 덱 클래스 구현

### ✔️ CircularQueue에서 상속
```
class CircularDeque(CircularQueue)
```

### ✔️ 덱의 생성자 (생성자는 상속되지 않기 때문에 자식 클래스에서 다시 정의 필요)
```
def __init__(self):
    super().__init__()
```
- 생성자에서 front, rear, items와 같은 멤버변수는 추가로 선언하지 않아도 됨
- super() : 자식클래스에서 부모를 부르는 함수

### ✔️ 재사용 멤버들
- isEmpty, isFull, size, clear

### ✔️ 인터페이스 변경 멤버들
```
def addRear(self, item):
    self.enqueue(item)
def deleteFront(self):
    return self.dequeue() # 반환!
def getFront(self):
    return self.peek()
```

### ✔️ 추가로 구현할 메소드
- addFront
- deleteRear
- getRear

## ✅ 덱의 시간복잡도
- 모든 연산이 O(1), 삭제와 삽입 연산도 인덱스만 변경하면 되므로 O(1)

# 5.6 우선순위 큐

---

## ✅ 우선순위 큐란?
- 실생활에서의 우선순위 :  도로에서의 자동차 우선순위

## ✅ 우선순위 큐(priority queue)
- 우선순위의 개념을 큐에 도입한 자료구조
- 모든 데이터가 우선순위를 가짐
- 입력 순서와 상관없이 우선순위가 높은 데이터가 먼저 출력
- 가장 일반적인 큐로 볼 수 있음 -> 이유 : 우선순위를 어떻게 정하느냐에 따라 스택이나 큐로 얼마든지 사용 가능
- 응용 분야 : 시뮬레이션, 네트워크 트래픽 제어, 운영체제에서의 작업 스케줄링, 수치 해석적인 계산 등

## ✅ 우선순위 큐의 추상자료형

### 데이터
- 우선순위를 가진 요소들의 모음

### 연산
- PriorityQueue() : 비어 있는 우선순위 큐 생성
- isEmpty() : 우선순위 큐가 공백상태인지 검사
- enqueue() : 우선순위를 가진 항목 e 추가
- dequeue() : 가장 우선순위가 높은 항목을 꺼내서 반환
- peek() : 가장 우선순위가 높은 요소를 삭제하지 않고 반환
- size() : 우선순위 큐의 모든 항목들의 개수 반환
- clear() : 우선순위 코를 공백상태로 만듦

## ✅ 우선순위 코의 삽입과 삭제연산

![](https://user-images.githubusercontent.com/77424107/197556553-e8636d89-8e2b-4aae-94f8-448ac991fd9f.png)

- 항목들이 일렬로 나열되어 있지 않음
- 한 순간에 가장 우선순위가 높은 항목만 알면 됨
- 선형 자료구조로 보기 어려움
- 구현 : 배열구조/연결된구조/힙트리

## ✅ 정렬되지 않은 배열을 이용한 우선순위 큐의 구현

- 삽입연산 : 리스트의 맨 뒤에 삽입(O(1))
- 우선순위가 높은 항목의 인덱스를 반환하는 함수를 따로 생성하여 삭제 연산 수행 

## ✅ 시간복잡도

### ✔️ 정렬되지 않은 리스트 사용할 경우
- 리스트 크기와 용량이 같아져 copy하는 경우를 제외하고는 대부분의 경우 O(1)
- findMaxIndex() : O(n)
- dequeue(), peek() : O(n)

### ✔️ 정렬된 리스트 사용
- enqueue() : 무조건 맨 뒤에 추가하는 것이 아니라 순위를 비교하여 자신의 자리에 맞게 삽입되어야 하므로 O(n)
- dequeue(), peek() : 가장 우선순위가 높은 항목의 위치가 항상 정해져 있기 때문에 O(1)

### ✔️ 힙트리
- enqueue(), dequeue() : O(logn)
- peek() : O(1)

# 5.7 우선순위 큐의 응용 : 전략적인 미로 탐색

---

## ✅ 전략(출구의 위치를 알고 있다고 가정)
- 가능한 한 가까운 방향을 먼저 선택

## ✅ 과정
- 우선순위 큐에는 (x,y,-d) 형태의 튜플을 저장하도록 함
- (x,y)는 현재 좌표. -d는 우선순위 값. 거리를 음수로 저장한 것은 거리가 가까울 수록 더 우선순위가 높아야하기(더 큰 값이 되어야 하기)때문.
- 현재 위치에서 갈 수 있는 모든 위치를 (x,y,-d)의 형태로 우선순위 큐에 저장하고, 큐에 저장된 여러 가능한 위치 중 우선순위가 가장 높은 위치에서 다시 시작
- 두 지점 사이 거리 구하는 함수 : math 모듈에 있는 sqrt() 함수

## ✅ 우선순위 큐의 주요 응용
- 압축을 위한 허프만 코딩 트리 : 빈도가 가장 작은 두 노드를 선택하기 위함
- Krustal MST 알고리즘 : MST(최소비용신장트리)에 포함되지 않은 간선 중에서 가중치가 가장 작은 간선을 반복적으로 선택하기 위함
- Dijkstra의 최단거리 알고리즘 : 최단거리가 찾아지지 않은 정점들 중에서 가장 거리가 가까운 정점 선택
- 인공지능의 A* 알고리즘 : 상태 공간 트리(state space tree)에서 가장 가능성이 높은(promising) 경로를 먼저 선택하여 시도하기 위함
 